{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"HPC \u00b6 Overview \u00b6 StreamHPC is a software development company in parallel software for many-core processors. The Supercomputing Blog FastC++: Coding Cpp Efficiently Heterogeneous Computing \u00b6 Introduction to Parallel Computing MPI (Message Passing Interface) \u00b6 MPI Forum : the standardization forum for MPI Open MPI : Open Source High Performance Computing. Concurrency \u00b6 task switching hardware concurrency Multi-Processing \u00b6 IPC \u00b6 Interprocess Communications (Microsoft) Inter-Process Communication (IPC) Introduction and Sample Code Multi-Threading \u00b6 POSIX C: pthread boost::thread c++11: std::thread Software Optimization \u00b6","title":"Home"},{"location":"#HPC","text":"","title":"HPC"},{"location":"#Overview","text":"StreamHPC is a software development company in parallel software for many-core processors. The Supercomputing Blog FastC++: Coding Cpp Efficiently","title":"Overview"},{"location":"#Heterogeneous_Computing","text":"Introduction to Parallel Computing","title":"Heterogeneous Computing"},{"location":"#MPI_Message_Passing_Interface","text":"MPI Forum : the standardization forum for MPI Open MPI : Open Source High Performance Computing.","title":"MPI (Message Passing Interface)"},{"location":"#Concurrency","text":"task switching hardware concurrency","title":"Concurrency"},{"location":"#Multi-Processing","text":"","title":"Multi-Processing"},{"location":"#IPC","text":"Interprocess Communications (Microsoft) Inter-Process Communication (IPC) Introduction and Sample Code","title":"IPC"},{"location":"#Multi-Threading","text":"POSIX C: pthread boost::thread c++11: std::thread","title":"Multi-Threading"},{"location":"#Software_Optimization","text":"","title":"Software Optimization"},{"location":"cpu/","text":"CPU \u00b6 Overview \u00b6 Intel\u00ae 64 and IA-32 Architectures Software Developer Manuals Hotspots, FLOPS, and uOps: To-The-Metal CPU Optimization","title":"Overview"},{"location":"cpu/#CPU","text":"","title":"CPU"},{"location":"cpu/#Overview","text":"Intel\u00ae 64 and IA-32 Architectures Software Developer Manuals Hotspots, FLOPS, and uOps: To-The-Metal CPU Optimization","title":"Overview"},{"location":"cpu/benchmark/","text":"CPU Benchmark \u00b6 Sysbench \u00b6 Sysbench -- Scriptable database and system performance benchmark, a cross-platform and multi-threaded benchmark tool Bash sysbench --test = cpu --cpu-max-prime = 20000 --num-threads = 4 run htop \u00b6 htop - an interactive process viewer for Unix htop explained - Explanation of everything you can see in htop/top on Linux \u538b\u529b\u6d4b\u8bd5 \u00b6 https://www.tecmint.com/linux-cpu-load-stress-test-with-stress-ng-tool/ Bash cat /sys/class/thermal/thermal_zone0/temp # stress stress --cpu 4 --io 4 --vm 1 --vm-bytes 1G","title":"Benchmark"},{"location":"cpu/benchmark/#CPU_Benchmark","text":"","title":"CPU Benchmark"},{"location":"cpu/benchmark/#Sysbench","text":"Sysbench -- Scriptable database and system performance benchmark, a cross-platform and multi-threaded benchmark tool Bash sysbench --test = cpu --cpu-max-prime = 20000 --num-threads = 4 run","title":"Sysbench"},{"location":"cpu/benchmark/#htop","text":"htop - an interactive process viewer for Unix htop explained - Explanation of everything you can see in htop/top on Linux","title":"htop"},{"location":"cpu/benchmark/#\u538b\u529b\u6d4b\u8bd5","text":"https://www.tecmint.com/linux-cpu-load-stress-test-with-stress-ng-tool/ Bash cat /sys/class/thermal/thermal_zone0/temp # stress stress --cpu 4 --io 4 --vm 1 --vm-bytes 1G","title":"\u538b\u529b\u6d4b\u8bd5"},{"location":"cpu/info/","text":"CPU Info \u00b6 Overview \u00b6 8 commands to check cpu information on Linux: /proc/cpuinfo : The /proc/cpuinfo file contains details about individual cpu cores. lscpu : simply print the cpu hardware details in a user-friendly format cpuid : fetches CPUID information about Intel and AMD x86 processors nproc : just prints out the number of processing units available, note that the number of processing units might not always be the same as number of cores dmidecode : displays some information about the cpu, which includes the socket type, vendor name and various flags hardinfo : would produce a large report about many hardware parts, by reading files from the /proc directory lshw -class processor : lshw by default shows information about various hardware parts, and the -class option can be used to pickup information about a specific hardware part inxi : a script that uses other programs to generate a well structured easy to read report about various hardware components on the system ARM CPU features \u00b6 Runtime detection of CPU features on an ARMv8-A CPU","title":"CPU Info"},{"location":"cpu/info/#CPU_Info","text":"","title":"CPU Info"},{"location":"cpu/info/#Overview","text":"8 commands to check cpu information on Linux: /proc/cpuinfo : The /proc/cpuinfo file contains details about individual cpu cores. lscpu : simply print the cpu hardware details in a user-friendly format cpuid : fetches CPUID information about Intel and AMD x86 processors nproc : just prints out the number of processing units available, note that the number of processing units might not always be the same as number of cores dmidecode : displays some information about the cpu, which includes the socket type, vendor name and various flags hardinfo : would produce a large report about many hardware parts, by reading files from the /proc directory lshw -class processor : lshw by default shows information about various hardware parts, and the -class option can be used to pickup information about a specific hardware part inxi : a script that uses other programs to generate a well structured easy to read report about various hardware components on the system","title":"Overview"},{"location":"cpu/info/#ARM_CPU_features","text":"Runtime detection of CPU features on an ARMv8-A CPU","title":"ARM CPU features"},{"location":"cpu/intrinsics/","text":"CPU Instructions & Intrinsics \u00b6 Overview \u00b6 Compiler Intrinsics Assembly \u00b6 x86 Assembly winasm : The x86 Assembly community and official home of WinAsm Studio and HiEditor Easy Code Visual assembly IDE 0xAX/asm : Learning assembly for linux-x64 SIMD \u00b6 Intel MMX & SSE \u00b6 Intel Intrinsics Guide SSE (Streaming SIMD Extentions) C++ - Getting started with SSE SSE - Vectorizing conditional code SSE\u56fe\u50cf\u7b97\u6cd5\u4f18\u5316\u7cfb\u5217(cnblogs) ARM NEON \u00b6 Arm NEON technology is an advanced SIMD (single instruction multiple data) architecture extension for the Arm Cortex-A series and Cortex-R52 processors. NEON Intrinsics Reference ARM NEON Tutorial in C and Assembler ARM NEON\u7f16\u7a0b\u521d\u63a2\u2014\u2014\u4e00\u4e2a\u7b80\u5355\u7684BGR888\u8f6cYUV444\u5b9e\u4f8b\u8be6\u89e3 Compiler Options: test ARM NEON Bash gcc -dM -E -x c /dev/null | grep -i -E \"(SIMD|NEON|ARM)\" Raspberry Pi 3 Model B g++ options Bash -std = c++11 -O3 -march = native -mfpu = neon-vfpv4 -mfloat-abi = softfp -ffast-math for the compilation error error: \u2018vfmaq_f32\u2019 was not declared in this scope , you might add the option -mfpu=neon-vfpv4 to enable __ARM_FEATURE_FMA in arm_neon.h Reference Books: NEON Programmer\u2019s Guide ARM\u00ae NEON Intrinsics Reference Converter \u00b6 jratcliff63367/sse2neon From ARM NEON* to Intel\u00ae SSE - The Automatic Porting Solution, Tips and Tricks","title":"Instructions & Intrinsics"},{"location":"cpu/intrinsics/#CPU_Instructions__Intrinsics","text":"","title":"CPU Instructions &amp; Intrinsics"},{"location":"cpu/intrinsics/#Overview","text":"Compiler Intrinsics","title":"Overview"},{"location":"cpu/intrinsics/#Assembly","text":"x86 Assembly winasm : The x86 Assembly community and official home of WinAsm Studio and HiEditor Easy Code Visual assembly IDE 0xAX/asm : Learning assembly for linux-x64","title":"Assembly"},{"location":"cpu/intrinsics/#SIMD","text":"","title":"SIMD"},{"location":"cpu/intrinsics/#Intel_MMX__SSE","text":"Intel Intrinsics Guide SSE (Streaming SIMD Extentions) C++ - Getting started with SSE SSE - Vectorizing conditional code SSE\u56fe\u50cf\u7b97\u6cd5\u4f18\u5316\u7cfb\u5217(cnblogs)","title":"Intel MMX &amp; SSE"},{"location":"cpu/intrinsics/#ARM_NEON","text":"Arm NEON technology is an advanced SIMD (single instruction multiple data) architecture extension for the Arm Cortex-A series and Cortex-R52 processors. NEON Intrinsics Reference ARM NEON Tutorial in C and Assembler ARM NEON\u7f16\u7a0b\u521d\u63a2\u2014\u2014\u4e00\u4e2a\u7b80\u5355\u7684BGR888\u8f6cYUV444\u5b9e\u4f8b\u8be6\u89e3 Compiler Options: test ARM NEON Bash gcc -dM -E -x c /dev/null | grep -i -E \"(SIMD|NEON|ARM)\" Raspberry Pi 3 Model B g++ options Bash -std = c++11 -O3 -march = native -mfpu = neon-vfpv4 -mfloat-abi = softfp -ffast-math for the compilation error error: \u2018vfmaq_f32\u2019 was not declared in this scope , you might add the option -mfpu=neon-vfpv4 to enable __ARM_FEATURE_FMA in arm_neon.h Reference Books: NEON Programmer\u2019s Guide ARM\u00ae NEON Intrinsics Reference","title":"ARM NEON"},{"location":"cpu/intrinsics/#Converter","text":"jratcliff63367/sse2neon From ARM NEON* to Intel\u00ae SSE - The Automatic Porting Solution, Tips and Tricks","title":"Converter"},{"location":"cpu/omp/","text":"OpenMP \u00b6 The OpenMP API specification for parallel programming, an Application Program Interface (API) that may be used to explicitly direct multi-threaded, shared memory parallelism . OpenMP\u6709\u4e24\u79cd\u5e38\u7528\u7684\u5e76\u884c\u5f00\u53d1\u5f62\u5f0f: \u4e00\u662f\u901a\u8fc7\u7b80\u5355\u7684 fork/join \u5bf9\u4e32\u884c\u7a0b\u5e8f\u5e76\u884c\u5316\uff0c\u4e8c\u662f\u91c7\u7528 \u5355\u7a0b\u5e8f\u591a\u6570\u636e \u5bf9\u4e32\u884c\u7a0b\u5e8f\u5e76\u884c\u5316\u3002 OpenMP Tutorials OpenMP in a nutshell CMakeLists.txt find_package ( OpenMP ) if ( OPENMP_FOUND ) set ( CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} ${OpenMP_C_FLAGS}\" ) set ( CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} ${OpenMP_CXX_FLAGS}\" ) set ( CMAKE_EXE_LINKER_FLAGS \"${CMAKE_EXE_LINKER_FLAGS} ${OpenMP_EXE_LINKER_FLAGS}\" ) endif ()","title":"OpenMP"},{"location":"cpu/omp/#OpenMP","text":"The OpenMP API specification for parallel programming, an Application Program Interface (API) that may be used to explicitly direct multi-threaded, shared memory parallelism . OpenMP\u6709\u4e24\u79cd\u5e38\u7528\u7684\u5e76\u884c\u5f00\u53d1\u5f62\u5f0f: \u4e00\u662f\u901a\u8fc7\u7b80\u5355\u7684 fork/join \u5bf9\u4e32\u884c\u7a0b\u5e8f\u5e76\u884c\u5316\uff0c\u4e8c\u662f\u91c7\u7528 \u5355\u7a0b\u5e8f\u591a\u6570\u636e \u5bf9\u4e32\u884c\u7a0b\u5e8f\u5e76\u884c\u5316\u3002 OpenMP Tutorials OpenMP in a nutshell CMakeLists.txt find_package ( OpenMP ) if ( OPENMP_FOUND ) set ( CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} ${OpenMP_C_FLAGS}\" ) set ( CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} ${OpenMP_CXX_FLAGS}\" ) set ( CMAKE_EXE_LINKER_FLAGS \"${CMAKE_EXE_LINKER_FLAGS} ${OpenMP_EXE_LINKER_FLAGS}\" ) endif ()","title":"OpenMP"},{"location":"cpu/others/","text":"Others \u00b6 OpenACC \u00b6 OpenACC is a user-driven directive-based performance-portable parallel programming model designed for scientists and engineers interested in porting their codes to a wide-variety of heterogeneous HPC hardware platforms and architectures with significantly less programming effort than required with a low-level model. Intel TBB \u00b6 Intel Threading Building Blocks (TBB) lets you easily write parallel C++ programs that take full advantage of multicore performance , that are portable and composable, and that have future-proof scalability. Intel IPP \u00b6","title":"Others"},{"location":"cpu/others/#Others","text":"","title":"Others"},{"location":"cpu/others/#OpenACC","text":"OpenACC is a user-driven directive-based performance-portable parallel programming model designed for scientists and engineers interested in porting their codes to a wide-variety of heterogeneous HPC hardware platforms and architectures with significantly less programming effort than required with a low-level model.","title":"OpenACC"},{"location":"cpu/others/#Intel_TBB","text":"Intel Threading Building Blocks (TBB) lets you easily write parallel C++ programs that take full advantage of multicore performance , that are portable and composable, and that have future-proof scalability.","title":"Intel TBB"},{"location":"cpu/others/#Intel_IPP","text":"","title":"Intel IPP"},{"location":"dsp/","text":"DSP \u00b6","title":"Overview"},{"location":"dsp/#DSP","text":"","title":"DSP"},{"location":"gpu/","text":"GPU \u00b6 https://github.com/cggos/multicore_gpu_programming Overview \u00b6 GPU\u4e16\u754c\u6280\u672f\u8bba\u575b General-Purpose Computation on Graphics Hardware","title":"Overview"},{"location":"gpu/#GPU","text":"https://github.com/cggos/multicore_gpu_programming","title":"GPU"},{"location":"gpu/#Overview","text":"GPU\u4e16\u754c\u6280\u672f\u8bba\u575b General-Purpose Computation on Graphics Hardware","title":"Overview"},{"location":"gpu/benchmark/","text":"GPU Benchmark \u00b6 For the Raspberry Pi GPU benchmark, use the OpenGL 2.1 test that comes with GeeXLab msalvaris/gpu_monitor : Monitor your GPUs whether they are on a single computer or in a cluster Benchmark Your Graphics Card On Linux Bash watch -n 10 nvidia-smi # \u6bcf\u969410\u79d2\u66f4\u65b0\u4e00\u4e0b\u663e\u5361 # on Android watch -n 0 .1 adb shell cat /sys/class/kgsl/kgsl-3d0/gpu_busy_percentage # 0.1s","title":"Benchmark"},{"location":"gpu/benchmark/#GPU_Benchmark","text":"For the Raspberry Pi GPU benchmark, use the OpenGL 2.1 test that comes with GeeXLab msalvaris/gpu_monitor : Monitor your GPUs whether they are on a single computer or in a cluster Benchmark Your Graphics Card On Linux Bash watch -n 10 nvidia-smi # \u6bcf\u969410\u79d2\u66f4\u65b0\u4e00\u4e0b\u663e\u5361 # on Android watch -n 0 .1 adb shell cat /sys/class/kgsl/kgsl-3d0/gpu_busy_percentage # 0.1s","title":"GPU Benchmark"},{"location":"gpu/languages/","text":"Languages \u00b6 Overview \u00b6 CUDA vs OpenCL: Which should I use? OpenCL \u00b6 OpenCL\u2122 (Open Computing Language) is the open, royalty-free standard for cross-platform, parallel programming of diverse processors found in personal computers, servers, mobile devices and embedded platforms. install OpenCL Bash # required: Ubuntu 16.04, nvidia GPU and nvidia driver installed sudo apt-get install nvidia-prime nvidia-modprobe nvidia-opencl-dev sudo ln -s /usr/lib/x86_64-linux-gnu/libOpenCL.so.1 /usr/local/lib/libOpenCL.so build program Bash g++ main.cpp -lOpenCL CUDA \u00b6 CUDA\u00ae is a parallel computing platform and programming model developed by NVIDIA for general computing on graphical processing units (GPUs). CUDA Zone ArchaeaSoftware/cudahandbook CUDA for ARM Platforms is Now Available Thrust \u00b6 Thrust Thrust in CUDA Toolkit","title":"Languages"},{"location":"gpu/languages/#Languages","text":"","title":"Languages"},{"location":"gpu/languages/#Overview","text":"CUDA vs OpenCL: Which should I use?","title":"Overview"},{"location":"gpu/languages/#OpenCL","text":"OpenCL\u2122 (Open Computing Language) is the open, royalty-free standard for cross-platform, parallel programming of diverse processors found in personal computers, servers, mobile devices and embedded platforms. install OpenCL Bash # required: Ubuntu 16.04, nvidia GPU and nvidia driver installed sudo apt-get install nvidia-prime nvidia-modprobe nvidia-opencl-dev sudo ln -s /usr/lib/x86_64-linux-gnu/libOpenCL.so.1 /usr/local/lib/libOpenCL.so build program Bash g++ main.cpp -lOpenCL","title":"OpenCL"},{"location":"gpu/languages/#CUDA","text":"CUDA\u00ae is a parallel computing platform and programming model developed by NVIDIA for general computing on graphical processing units (GPUs). CUDA Zone ArchaeaSoftware/cudahandbook CUDA for ARM Platforms is Now Available","title":"CUDA"},{"location":"gpu/languages/#Thrust","text":"Thrust Thrust in CUDA Toolkit","title":"Thrust"},{"location":"gpu/platforms/","text":"Platforms \u00b6 MALI GPU \u00b6 ARM MALI GPU Nvidia GPU \u00b6 Install Nvidia S/H on Linux","title":"Platforms"},{"location":"gpu/platforms/#Platforms","text":"","title":"Platforms"},{"location":"gpu/platforms/#MALI_GPU","text":"ARM MALI GPU","title":"MALI GPU"},{"location":"gpu/platforms/#Nvidia_GPU","text":"Install Nvidia S/H on Linux","title":"Nvidia GPU"}]}